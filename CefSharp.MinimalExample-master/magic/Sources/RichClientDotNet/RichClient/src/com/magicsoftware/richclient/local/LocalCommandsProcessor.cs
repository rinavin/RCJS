using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using com.magicsoftware.richclient.tasks;
using com.magicsoftware.richclient.cache;
using com.magicsoftware.httpclient;
using com.magicsoftware.richclient.util;
using com.magicsoftware.unipaas.util;
using com.magicsoftware.util;
using com.magicsoftware.richclient.local.commands;
using com.magicsoftware.richclient.rt;
using com.magicsoftware.unipaas.management.tasks;
using com.magicsoftware.richclient.commands;
using com.magicsoftware.richclient.sources;
using util.com.magicsoftware.util;
#if PocketPC
using com.magicsoftware.richclient.mobile.util;
#endif

namespace com.magicsoftware.richclient.local
{
   /// <summary> 
   /// This class is responsible for accessing/handling local objects/commands.
   /// However, LocalCommandsProcessor can also be used when the client does have accessible network /web server. 
   /// The terms ‘Local’ and ‘Remote’ refer to local/remote objects (sources/databases) or commands that work on these objects. 
   /// For example, an offline task called from a non-offline task in connected mode is executed using LocalCommandsProcessor. 
   /// </summary>
   internal class LocalCommandsProcessor : CommandsProcessorBase
   {
      private static LocalCommandsProcessor _instance; //singleton

      // execution properties generated by the last connected session of an offline program.
      private MgProperties _lastOfflineExecutionProperties;
      private MgProperties LastOfflineExecutionProperties
      {
         get
         {
            Debug.Assert(HandleFiles.isExists(GetLastOfflineExecutionPropertiesFileName()));
            if (_lastOfflineExecutionProperties == null)
               _lastOfflineExecutionProperties = new MgProperties(GetLastOfflineExecutionPropertiesFileName());
            return _lastOfflineExecutionProperties;
         }
      }

      // <return>true if the locals command processor can start / be used without accessible network /web server.</return>
      public bool CanStartWithoutNetwork
      {
         get
         {
            return (HandleFiles.isExists(GetLastOfflineExecutionPropertiesFileName()));
         }
      }

      private LocalRunTimeCommandFactory _localRunTimeCommandFactory;

      /// <summary> create/return the single instance of the class.</summary>
      internal static LocalCommandsProcessor GetInstance()
      {
         if (_instance == null)
         {
            lock (typeof(LocalCommandsProcessor))
            {
               if (_instance == null)
                  _instance = new LocalCommandsProcessor();
            }
         }
         return _instance;
      }

      /// <summary>CTOR</summary>
      private LocalCommandsProcessor()
      {
         _localRunTimeCommandFactory = new LocalRunTimeCommandFactory();
      }

      /// <summary>
      ///  Initializes the encryptor that handles encryption/decryption of cached content (this functionality is currently embedded in the PersistentOnlyCacheManager..)
      /// </summary>
      internal void InitializeEncryptor()
      {
         // retrieve the required encryption state (enabled/disabled) and key:
         bool disableEncryption  = GetLastOfflineExecutionPropertyBool(ConstInterface.DISABLE_ENCRYPTION);
         string encryptionKeyStr = LastOfflineExecutionProperties.getProperty(ConstInterface.ENCRYPTION_KEY);
         byte[] encryptionKey = null;

         if (!String.IsNullOrEmpty(encryptionKeyStr))
         {
            // TODO: Scrambling the encryption key in the execution.properties_LastOffline file is not secured enough!
            encryptionKeyStr = Scrambler.UnScramble(encryptionKeyStr, 0, encryptionKeyStr.Length - 1);
            encryptionKey = Encoding.Default.GetBytes(encryptionKeyStr);
         }

         // initialize the encryptor:
         IEncryptor encryptor = PersistentOnlyCacheManager.CreateInstance(disableEncryption, encryptionKey);
      }

      /// <summary>
      /// verify that the last initial response file saved on the client for offline execution is valid (otherwise remove it).
      /// the last saved initial response file becomes invalid in the following case:
      ///   (*) the executed program's public name (ClientManager.Instance.getPrgName()) doesn't match the one saved in the last initial response file.
      /// </summary>
      internal void VerifyLastOfflineInitialResponseFile()
      {
         InitializeEncryptor();

         // extract the program's public name from the last :
         string initialResponsePrgName = GetPublicNameFromLastOfflineInitialResponse();

         /// the last saved initial response file becomes invalid in case the executed program's public name (ClientManager.Instance.getPrgName()) 
         ///   doesn't match the one saved in the last initial response file.
         if (!ClientManager.Instance.getPrgName().Equals(initialResponsePrgName))
         {
            string lastOfflineExecutionFileName = GetLastOfflineExecutionPropertiesFileName();
            HandleFiles.deleteFile(lastOfflineExecutionFileName);
         }
      }

      /// <summary>
      /// locate the 'StartupProgram' element in the initial response (execution.properties_LastOffline_DEBUG_InitialResponse.xml file), 
      /// and (if found) within it the 'publicName' attribute:
      /// "<StartupProgram publicName="AAA">"
      /// </summary>
      /// <returns>the located public name.</returns>
      internal string GetPublicNameFromLastOfflineInitialResponse()
      {
         string publicName = "";
         string initialResponse = GetLastOfflineInitialResponse();

         // locate the 'StartupProgram' element in the initial response:
         int startupProgramIdx = initialResponse.IndexOf(ConstInterface.MG_TAG_STARTUP_PROGRAM);
         if (startupProgramIdx > -1)
         {
            // and (if found) within it the 'publicName' attribute
            initialResponse = initialResponse.Substring(startupProgramIdx + ConstInterface.MG_TAG_STARTUP_PROGRAM.Length);
            int publicNameIdx = initialResponse.IndexOf(ConstInterface.MG_ATTR_PUBLIC_NAME);
            Debug.Assert(publicNameIdx > -1);
            initialResponse = initialResponse.Substring(publicNameIdx + ConstInterface.MG_ATTR_PUBLIC_NAME.Length);
            int publicNameValIdx = initialResponse.IndexOf("\"");
            Debug.Assert(publicNameValIdx > -1);
            publicNameValIdx++;
            initialResponse = initialResponse.Substring(publicNameValIdx);
            int publicNameValEndIdx = initialResponse.IndexOf("\"");
            Debug.Assert(publicNameValIdx > -1);
            int publicNameLength = publicNameValEndIdx;
            publicName = initialResponse.Substring(0, publicNameLength);
         }

         return publicName;
      }

      /// <summary>
      /// Returns true if there is an indication of unsynchronized metadata in last execution, to instruct client to start in connected mode
      /// even when execution property ConnectOnStartup = N
      /// </summary>
      /// <returns></returns>
      internal bool IsUnsyncronizedMetadata()
      {
         bool ret = false;

         string val = LastOfflineExecutionProperties.getProperty(ConstInterface.MG_TAG_UNSYNCRONIZED_METADATA);
         if (!String.IsNullOrEmpty(val))
            ret = val.Equals("Y", StringComparison.CurrentCultureIgnoreCase);

         return ret;
      }

      /// <summary>
      /// Saves an indication of unsynchronized metadata in LastOffline to instruct client to start in connected mode next time
      /// </summary>
      internal void SaveUnsyncronizedMetadataFlagInLastOfflineFile()
      {
         String fileName = GetLastOfflineExecutionPropertiesFileName();
         String fileTime = HandleFiles.getFileTime(fileName);

         MgProperties offlineExecutionProps = LastOfflineExecutionProperties.Clone();

         offlineExecutionProps.Add(ConstInterface.MG_TAG_UNSYNCRONIZED_METADATA, "Y");

         String initialResponse = offlineExecutionProps[ConstInterface.INITIAL_RESPONSE];
         if (GetLastOfflineExecutionPropertyBool(ConstInterface.DISABLE_ENCRYPTION))
         {
            initialResponse = XMLConstants.CDATA_START + OSEnvironment.EolSeq + initialResponse + OSEnvironment.EolSeq + XMLConstants.CDATA_END;
            offlineExecutionProps[ConstInterface.INITIAL_RESPONSE] = initialResponse;
         }

         offlineExecutionProps.WriteToXMLFile(fileName);
         HandleFiles.setFileTime(fileName, fileTime);
      }

      /// <summary> Saves the initial response in the LastOffline file. </summary>
      /// <param name="initialResponse"></param>
      internal void SaveInitialResponseInLastOfflineFile(String initialResponse)
      {
         String fileName = GetLastOfflineExecutionPropertiesFileName();
         String fileTime = HandleFiles.getFileTime(fileName);

         LastOfflineExecutionProperties[ConstInterface.INITIAL_RESPONSE] = initialResponse;

         LastOfflineExecutionProperties.WriteToXMLFile(fileName);
         HandleFiles.setFileTime(fileName, fileTime);
      }

      /// <summary> Initializes the Cache manager by proving it the required details from 
      /// execution properties like, whether the encryption is on/off and the encryption key. </summary>
      /// <returns></returns>
      internal override bool StartSession()
      {
         // Sources integrity is needed when client STARTS in connected mode (Initialization phase in Remote session).
         // Not applicable in Local session, even after establishing connection with server to execute server operation.
         ApplicationSourcesManager.GetInstance().DisableSourceIntegrity();

         // Verify that the last initial response file saved on the client for offline execution is valid:
         VerifyLastOfflineInitialResponseFile();

         // Recheck if last offline response file still exists. It might have been deleted from VerifyInitialResponseProgramName
         bool canStartWithoutNetwork = CanStartWithoutNetwork;
         if (canStartWithoutNetwork)
         {
            ClientManager.Instance.ShouldScrambleAndUnscrambleMessages = GetShouldSecureMessages();
            ExecuteInitialRequest();
         }

         return canStartWithoutNetwork;
      }

      /// <summary> Loads the first response for executing the first program from the local file. </summary>
      private void ExecuteInitialRequest()
      {
         // Before starting the execution, check if any failure was occurred during updating the local data in last execution
         SourcesSyncStatus sourcesSyncStatus = ApplicationSourcesManager.GetInstance().SourcesSyncStatus;
         if (sourcesSyncStatus.TablesIncompatibleWithDataSources == true)
         {
            // structures of tables in local database does not match with their sources
            String errorMessage = ClientManager.Instance.getMessageString(MsgInterface.RC_ERROR_INCOMPATIBLE_DATASOURCES);
            throw new InvalidSourcesException(errorMessage, null);
         }
         else if (sourcesSyncStatus.InvalidSources == true)
         {
            // sources are not synchronized
            String errorMessage = ClientManager.Instance.getMessageString(MsgInterface.RC_ERROR_OFFLINE_NEXT_EXECUTION_INVALID_SOURCES);
            throw new InvalidSourcesException(errorMessage, null);
         }
         
         String initialResponseString = GetLastOfflineInitialResponse();
         FlowMonitorQueue.Instance.enable(false);
         ClientManager.Instance.ProcessResponse(initialResponseString, 0, new OpeningTaskDetails(), null);
      }

      /// <summary>
      /// Loads the program whose task id is 'startupProgram' into the appropriate
      /// MGData instance. 
      /// </summary>
      internal void LoadStartupProgram()
      {
         Debug.Assert(startupProgram != null);

         if (ClientManager.Instance.LocalManager.ApplicationDefinitions.TaskDefinitionIdsManager.CanExecuteTask(startupProgram))
         {
             Task mainProg = MGDataCollection.Instance.GetMainProgByCtlIdx(0);
             MGData mgd = MGDataCollection.Instance.GetMGDataForStartupProgram();
             int mgdId = mgd.GetId();
             string taskUrl = LocalRunTimeCommandOpenTask.getXmlTaskURL(ClientManager.Instance.LocalManager.ApplicationDefinitions.TaskDefinitionIdsManager, startupProgram);
             ClientManager.Instance.ProcessResponse(taskUrl, mgdId, new OpeningTaskDetails(mainProg, mainProg, null), null);
         }
         else
             throw new ApplicationException(ClientManager.Instance.getMessageString(MsgInterface.CSTIO_STR_ERR2));
      }

      /// <summary>
      /// execute all pending commands - create the equivalent local commands and invoke its' execute method
      /// </summary>
      /// <param name="sendingInstruction"></param>
      /// <param name="sessionStage"></param>
      /// <param name="res"></param>
      internal override void Execute(SendingInstruction sendingInstruction, SessionStage sessionStage, IResultValue res)
      {
          MGDataCollection mgDataTab = MGDataCollection.Instance;

         // loop on all MGData
         for (int i = 0; i < mgDataTab.getSize(); i++)
         {
            MGData mgd = mgDataTab.getMGData(i);
            if (mgd != null && !mgd.IsAborting)
            {
               CommandsTable commands = mgd.CmdsToServer;

               // go over all commands
               while (commands.getSize() > 0)
               {
                  // extract command from CmdsToServer
                  IClientCommand command = commands.ExtractCommand(0);
                  LocalRunTimeCommandBase localRunTimeCommand = _localRunTimeCommandFactory.CreateLocalRunTimeCommand(command);
                  localRunTimeCommand.Execute();
               }

               Debug.Assert(mgd.CmdsToClient.getSize() == 0, "Not all commands were executed");
            }
         }
      }

      /// <summary> Get the contents from the previously cached contents from the requested URL</summary>
      /// <param name="completeCachedFileRetrievalURL">complete cached file retrieval request (including the server-side time stamp), 
      /// e.g. http://[server]/[requester]?CTX=&CACHE=My Application_DbhDataIds.xml|31/07/2013%2020:15:15</param>
      /// <param name="decryptResponse">if true, the contents will be be decrypted using the 'encryptionKey' passed to 'PersistentOnlyCacheManager.SetProperties'.</param>
      /// <returns></returns>
      internal override byte[] GetContent(string completeCachedFileRetrievalURL, bool decryptResponse)
      {
         //TODO: Kaushal. Most of this code is similar to that in HttpManager.GetContent().
         //Check if this duplication can be avoided.
         String remoteTime = null;
         byte[] response = null;
         int indexOfCacheToken = completeCachedFileRetrievalURL.IndexOf(ConstInterface.RC_TOKEN_CACHED_FILE);

         //In disconnected state, we should reach here only for the cached files.
         Debug.Assert(indexOfCacheToken != -1);

         // split the url --> url and remote time
         string[] urlAndRemoteTimePair = HttpUtility.UrlDecode(completeCachedFileRetrievalURL, Encoding.UTF8).Split('|');
         String cachedFileRetrievalURL = urlAndRemoteTimePair[0]; // the cached file retrieval request without the timestamp, e.g. http://[server]/[requester]?CTX=&CACHE=MG1VAI3T_MP_0$$$_$_$_N02400$$$$G8FM01_.xml
         string cachedFileLocalURL = CacheUtils.URLToFileName(cachedFileRetrievalURL);

         if (urlAndRemoteTimePair.Length > 1 && urlAndRemoteTimePair[1] != null)
         {
            remoteTime = urlAndRemoteTimePair[1];

            //is the file encrypted?
            int indexOfNonEncryptedToken = remoteTime.IndexOf(ConstInterface.RC_TOKEN_NON_ENCRYPTED);
            if (indexOfNonEncryptedToken != -1)
            {
               decryptResponse = false;
               remoteTime = remoteTime.Substring(0, indexOfNonEncryptedToken - 1);
            }
         }

         ICacheManager cacheManager = PersistentOnlyCacheManager.GetInstance();
         if (remoteTime == null)
            response = cacheManager.GetFile(cachedFileLocalURL);
         else
            response = cacheManager.GetFile(cachedFileLocalURL, remoteTime);

         if (response != null)
         {
            if (decryptResponse)
            {
               IEncryptor encryptor = PersistentOnlyCacheManager.GetInstance();
               response = encryptor.Decrypt(response);
            }
         }
         else
         {
            throw new LocalSourceNotFoundException("Some of the required files are missing. Please restart the application when connected to the network.");
         }

         return response;
      }

      /// <summary>Returns file version saved in last offline response file. If not specified in the file, returns 0</summary>
      private int LastOfflineFileVersion
      {
         get
         {
            int lastOfflineFileVersion = 0;
            try
            {
               lastOfflineFileVersion = System.Convert.ToInt32(LastOfflineExecutionProperties[ConstInterface.LAST_OFFLINE_FILE_VERSION]);
            }
            catch (System.Exception) { }

            return lastOfflineFileVersion;
         }
      }

      /// <summary> Get the initial response from the execution properties. </summary>
      /// <returns>initial response string</returns>
      internal String GetLastOfflineInitialResponse()
      {
         //Extract and decode the initial response from the execution properties
         IEncryptor encryptor = PersistentOnlyCacheManager.GetInstance();
         String initialResponseString = null;
         int lastOfflineFileVersion = LastOfflineFileVersion;

         byte[] initialResponseBytes = Encoding.Default.GetBytes(LastOfflineExecutionProperties[ConstInterface.INITIAL_RESPONSE]);

         if (encryptor.EncryptionDisabled)
            initialResponseString = Encoding.UTF8.GetString(initialResponseBytes, 0, initialResponseBytes.Length);
         else
         {
            if (lastOfflineFileVersion == 1)
               initialResponseBytes = Base64.decodeToByte(Encoding.ASCII.GetString(initialResponseBytes, 0, initialResponseBytes.Length));

            initialResponseBytes = encryptor.Decrypt(initialResponseBytes);
            initialResponseString = Encoding.UTF8.GetString(initialResponseBytes, 0, initialResponseBytes.Length);
         }

         return initialResponseString;
      }

      /// <summary></summary>
      /// <param name="propertyName">The name of a property that should be retrieved from last offline execution properties.</param>
      /// <returns>Boolean value of execution property.</returns>
      private bool GetLastOfflineExecutionPropertyBool(String propertyName)
      {
         bool ret = false;

         string val = LastOfflineExecutionProperties.getProperty(propertyName);
         if (!String.IsNullOrEmpty(val))
            ret = val.Equals("Y", StringComparison.CurrentCultureIgnoreCase);

         return ret;
      }

      /// <summary> Returns whether messages should be secured (scrambled). </summary>
      /// <returns></returns>
      private bool GetShouldSecureMessages()
      {
         string val = LastOfflineExecutionProperties.getProperty(ConstInterface.SECURE_MESSAGES);
         return (!String.IsNullOrEmpty(val)
                        ? val.Equals("Y", StringComparison.CurrentCultureIgnoreCase)
                        : !GetLastOfflineExecutionPropertyBool(ConstInterface.DISABLE_ENCRYPTION)); // Backwards compatibility: Until xpa 3.0, both messages and xml files were encrypted based on this single flag.
      }

      ///<summary>
      ///  !!.
      ///</summary>
      ///<returns>!!.</returns>
      internal string GetLastOfflineExecutionPropertiesFileName()
      {
         string executionPropertiesFileName = (ClientManager.Instance.LoadedExecutionPropertiesFileName != null
                                                  ? ClientManager.Instance.LoadedExecutionPropertiesFileName
                                                  : ConstInterface.EXECUTION_PROPERTIES_FILE_NAME);
         return (string.Format("{0}_{1}",
                               executionPropertiesFileName, ConstInterface.LAST_OFFLINE));
      }

      /// <summary>convert the file path on the server's file system or the url to the file name in the client's cached folder.</summary>
      /// <param name="serverFilename">a file name in the Server's file system.</param>
      /// <param name="task"></param>
      /// <param name="refreshClientCopy"></param>
      /// <returns>file name in the local file system.</returns>
      internal override string GetLocalFileName(string serverFilename, Task task, bool refreshClientCopy)
      {
         string localFileName = String.Empty;

         if (!String.IsNullOrEmpty(serverFilename))
         {
            if (Misc.isWebURL(serverFilename, ClientManager.Instance.getEnvironment().ForwardSlashUsage))
               localFileName = CacheUtils.URLToLocalFileName(serverFilename);
            else
               localFileName = CacheUtils.ServerFileToLocalFileName(serverFilename);

            if (!HandleFiles.isExists(localFileName))
            {
               localFileName = String.Empty;
               //TODO: Kaushal. Raise InAccessibleServer event.
            }
         }

         return localFileName;
      }

      /// <summary></summary>
      /// <param name="serverFileName"></param>
      /// <param name="fileContent"></param>
      /// <param name="contentType"></param>
      /// <returns></returns>
      internal override byte[] UploadFileToServer(string serverFileName, byte[] fileContent, string contentType)
      {
         //TODO: Kaushal. Raise InAccessibleServer event.
         throw new NotImplementedException();
      }

      /// <summary></summary>
      internal override void SendMonitorOnly()
      {
         //Do nothing.

      }

      /// <summary>
      /// get the argument string from the execution properties and build the argument list from it
      /// </summary>
      /// <returns></returns>
      internal override ArgumentsList BuildArgList()
      {
         ArgumentsList argumentsList = null;
         string argsString = ClientManager.Instance.getPrgArgs();

         if (argsString != null)
         {
            argumentsList = new ArgumentsList();
            argumentsList.FillListFromString(argsString);
         }
         return argumentsList;
      }

      /// <summary>
      /// 
      /// </summary>
      /// <returns></returns>
      internal override bool AllowParallel()
      {
         // offline programs can not be run as parallel
         return false;
      }
   }

   /// <summary> Signifies that the local source file is not available. </summary>
   internal class LocalSourceNotFoundException : ApplicationException
   {
      internal LocalSourceNotFoundException(String msg)
         : base(msg)
      {
      }
   }
}
